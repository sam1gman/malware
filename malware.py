import yara
import hashlib
import requests
import pefile
import time
import os
import magic


def print_intro():
    print("\n" + "=" * 60)
    print("         ü¶† MALWARE ANALYSIS TOOL ü¶†         ")
    print("        ---------------------------------      ")
    print("          by [Sam_gman]      ")
    print("         ---------------------------------      ")
    print("=" * 60)
    time.sleep(1)
    print("   üîç Performing in-depth analysis to keep you safe...   ")
    time.sleep(1)
    print("\n" + "=" * 60)
    print("     üöÄ Let‚Äôs get started! üöÄ ")
    print("=" * 60)
    time.sleep(1)


def scan_file_with_yara(file_path, rule_path):
    """Scan the file with YARA rules."""
    output = ""
    try:
        rules = yara.compile(filepath=rule_path)
        matches = rules.match(file_path)
        if matches:
            output += f"‚ö†Ô∏è Malicious file detected: {[match.rule for match in matches]}\n"
            for match in matches:
                output += f" - Rule: {match.rule}\n"
                if match.rule == "php_reverse_shell":
                    output += ("   üîÑ Context: This rule identifies a PHP reverse shell script, "
                               "often used to gain unauthorized remote access to a server.\n")
                elif match.rule == "php_reverse_shell_2":
                    output += ("   üîÑ Context: This variant of a PHP reverse shell can indicate attempts to bypass "
                               "security measures or establish persistent remote access.\n")
                elif match.rule == "WebShell__findsock_php_findsock_shell_php_reverse_shell":
                    output += ("   üîÑ Context: This rule indicates a web shell, a type of malicious script that "
                               "allows attackers to execute commands on the server remotely.\n")
                elif match.rule == "Cobalt_functions":
                    output += ("   üõ°Ô∏è Context: This rule indicates the presence of Cobalt Strike functionality, "
                               "commonly used in post-exploitation activities by threat actors.\n")
                elif match.rule == "Malware_Indicator":
                    output += (
                        "   üö® Context: This rule signifies that the file exhibits characteristics typical of malware, "
                        "such as known malicious code patterns.\n")
                elif match.rule == "RAT_Functions":
                    output += (
                        "   üïµÔ∏è Context: This rule indicates potential Remote Access Trojan (RAT) functionalities, "
                        "allowing unauthorized remote access to the system.\n")
                elif match.rule == "Virus_Win32":
                    output += (
                        "   ü¶† Context: This rule detects generic Win32 viruses that may affect Windows systems, "
                        "often causing harm by corrupting files or spreading to other systems.\n")
                elif match.rule == "Trojan":
                    output += (
                        "   üê¥ Context: This rule identifies a Trojan horse, a type of malware that pretends to be "
                        "harmless software but actually carries malicious code.\n")
                elif match.rule == "Keylogger":
                    output += (
                        "   üîë Context: This rule detects keyloggers, which capture keystrokes to steal sensitive "
                        "information such as passwords and credit card details.\n")
                elif match.rule == "Ransomware":
                    output += (
                        "   üí∞ Context: This rule indicates potential ransomware, which encrypts files and demands "
                        "a ransom for decryption.\n")
                elif match.rule == "Exploit_Code":
                    output += (
                        "   ‚öîÔ∏è Context: This rule detects known exploit code that can be used to compromise systems.\n")
                # Add more specific rules and contexts as needed
            output += ("üîç The detection indicates that the file contains patterns or signatures "
                       "consistent with known malicious behavior or characteristics.\n")
        else:
            output += "‚úÖ File is clean (No YARA match)\n"
    except Exception as e:
        output += f"‚ùå Error scanning file: {e}\n"
    return output


def get_file_hash(file_path, hash_algo='sha256'):
    """Generate the file hash (SHA-256 by default)."""
    hash_func = hashlib.new(hash_algo)
    with open(file_path, 'rb') as f:
        while chunk := f.read(8192):
            hash_func.update(chunk)
    return hash_func.hexdigest()


def check_virustotal(file_hash):
    """Check file hash against VirusTotal's database."""
    url = 'https://www.virustotal.com/vtapi/v2/file/report'
    params = {'apikey': API_KEY, 'resource': file_hash}

    try:
        response = requests.get(url, params=params)
        response.raise_for_status()  # Raise an error for bad responses (4xx or 5xx)

        # Log the raw response text for debugging
        print(f"Raw response from VirusTotal: {response.text}")

        # Attempt to decode the response as JSON
        result = response.json()

        output = ""
        if result.get('response_code') == 1:
            if result.get('positives', 0) > 0:
                output += f"‚ö†Ô∏è Malicious file detected by {result['positives']} AV engines!\n"
                output += "üõ°Ô∏è Detection results:\n"
                for engine, details in result['scans'].items():
                    if details['detected']:
                        output += f" - {engine}: {details['result']}\n"
                output += f"üîó Link to full VirusTotal report: {result['permalink']}\n"
            else:
                output += "‚úÖ File is clean (VirusTotal report shows no threats)\n"
        else:
            output += "‚ùå File not found in VirusTotal database\n"

    except requests.exceptions.HTTPError as e:
        output = f"‚ùå HTTP error occurred: {e}\n"
    except requests.exceptions.RequestException as e:
        output = f"‚ùå Request error occurred: {e}\n"
    except ValueError:
        output = "‚ùå Error decoding JSON response from VirusTotal.\n"
    except Exception as e:
        output = f"‚ùå Unexpected error occurred: {e}\n"

    return output


def upload_to_virustotal(file_path):
    """Upload the file to VirusTotal for scanning."""
    url = 'https://www.virustotal.com/vtapi/v2/file/scan'
    with open(file_path, 'rb') as f:
        files = {'file': f}
        params = {'apikey': API_KEY}
        response = requests.post(url, files=files, params=params)
        result = response.json()

        output = ""
        if 'resource' in result:
            output += "üì§ File uploaded to VirusTotal successfully.\n"
            output += f"üîç Scan ID: {result['resource']}\n"
            output += f"üåê You can check the scan results at: https://www.virustotal.com/gui/file/{result['resource']}\n"
        else:
            output += "‚ùå Failed to upload file. Response: " + str(result) + "\n"

        return output


MAGIC_NUMBERS = {
    b'\x7fELF': 'ELF Executable',                 # ELF
    b'MZ': 'PE Executable / DLL',                 # PE and DLL
    b'%PDF': 'PDF Document',                      # PDF
    b'\xff\xd8\xff': 'JPEG Image',                # JPEG
    b'\x89PNG': 'PNG Image',                      # PNG
    b'PK\x03\x04': 'ZIP Archive',                 # ZIP
    b'PK\x05\x06': 'Empty ZIP Archive',           # Empty ZIP
    b'PK\x01\x02': 'ZIP Archive (old)',           # Old ZIP
    b'GIF8': 'GIF Image',                         # GIF
    b'<?php': 'PHP File',                         # PHP
    b'RIFF': 'RIFF (WAV or AVI)',                 # RIFF
    b'OggS': 'OGG Audio',                         # OGG
    b'FWS': 'Flash (SWF)',                        # Flash
    b'\x00\x00\x01\x00': 'ICO Image',            # ICO
    b'~9PD': 'Photoshop Document',                # PSD
    b'<!DOCTYPE html>': 'HTML Document',          # HTML
    b'\x1f\x8b': 'Gzip Compressed File',          # Gzip
    b'Rar!': 'RAR Archive',                        # RAR
    b'7z\xBC\xAF': '7-Zip Archive',               # 7-Zip
    b'\x52\x61\x72\x21': 'RAR Archive',           # RAR (another signature)
    b'\x4D\x5A': 'Windows Executable (EXE / DLL)',# Windows EXE and DLL
    b'\x42\x5A': 'BZ2 Compressed File',           # BZ2
    b'\x4C\x6F\x61\x64': 'MP3 Audio',             # MP3
    b'ID3': 'MP3 Audio (ID3 tag)',                # ID3 Tag
}


def identify_file_type(file_path):
    """Identify the file type using magic numbers."""
    try:
        # Using python-magic to get MIME type
        mime_type = magic.from_file(file_path, mime=True)

        # Check for known magic numbers
        with open(file_path, 'rb') as f:
            file_signature = f.read(8)  # Read the first 8 bytes

        # Convert to hex for better readability in output
        hex_signature = file_signature.hex()

        for magic_number, file_type in MAGIC_NUMBERS.items():
            if file_signature.startswith(magic_number):
                return f"{file_type} (Signature: {hex_signature})"

        return f"Unknown file type (MIME: {mime_type}, Signature: {hex_signature})"
    except Exception as e:
        print(f"‚ùå Error identifying file type: {e}")
        return "Unknown file type"


def analyze_pe_file(file_path):
    """Analyze PE file using the pefile library."""
    output = ""
    try:
        pe = pefile.PE(file_path)
        output += f"\n--- Analyzing PE file: {file_path} ---\n"
        output += f"üîß Machine: {pe.FILE_HEADER.Machine}\n"
        output += f"üì¶ Number of Sections: {len(pe.sections)}\n"
        output += f"üìè Size of Optional Header: {pe.FILE_HEADER.SizeOfOptionalHeader} bytes\n"
        output += f"üïí Time Date Stamp: {pe.FILE_HEADER.TimeDateStamp}\n"

        # Sections Analysis
        for section in pe.sections:
            output += f"\nüóÇÔ∏è Section Name: {section.Name.decode().strip()}\n"
            output += f"üìè Section Size: {section.Misc_VirtualSize} bytes\n"
            output += f"üõ†Ô∏è Section Characteristics: {section.Characteristics}\n"

        # Imports
        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
            output += "\nüì• Imported Functions:\n"
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                output += f"üîå Library: {entry.dll.decode()}\n"
                for imp in entry.imports:
                    output += f" - {imp.name.decode() if imp.name else 'N/A'} (Address: {hex(imp.address)})\n"

        # Exports
        if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
            output += "\nüì§ Exported Functions:\n"
            for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
                output += f" - {exp.name.decode() if exp.name else 'N/A'} (Address: {hex(exp.address)})\n"

    except Exception as e:
        output += f"‚ùå Error analyzing PE file: {e}\n"

    return output


def analyze_file(file_path):
    """Full analysis of the file using YARA, VirusTotal, and PE analysis."""
    output = ""

    # Step 1: File type identification
    output += "\n--- Identifying file type ---\n"
    file_type = identify_file_type(file_path)
    output += f"File Type: {file_type}\n"

    # Step 2: YARA scanning (optional)
    yara_path = input("Do you have a YARA rules file to scan with? (yes/no):\n").strip().lower()
    if yara_path == 'yes':
        rule_path = input("Enter the path to your YARA rules file:\n").strip()
        output += "\n--- Scanning file with YARA ---\n"
        output += scan_file_with_yara(file_path, rule_path)

    # Step 3: File hashing and VirusTotal check
    output += "\n--- Checking file hash against VirusTotal ---\n"
    file_hash = get_file_hash(file_path)
    output += f"File hash (SHA-256): {file_hash}\n"
    output += check_virustotal(file_hash)

    # Option to upload the file to VirusTotal for scanning
    upload_choice = input("Do you want to upload the file to VirusTotal for scanning? (yes/no):\n").strip().lower()
    if upload_choice == 'yes':
        upload_output = upload_to_virustotal(file_path)
        output += upload_output

    # Step 4: PE analysis (only for PE files)
    if "Windows Executable" or "PE Executable" in file_type:
        pe_analysis_output = analyze_pe_file(file_path)
        output += pe_analysis_output

    return output


if __name__ == "__main__":
    print_intro()
    # Ask if user wants to provide a VirusTotal API key
    api_key_choice = input("Do you want to enter your VirusTotal API key? (yes/no):\n").strip().lower()
    API_KEY = ""
    if api_key_choice == 'yes':
        API_KEY = input("Enter your VirusTotal API key:\n")

    file_to_scan = input("Enter the path to your file that you want to scan:\n").strip()

    # Check if the file exists
    if not os.path.isfile(file_to_scan):
        print("‚ùå The specified file does not exist.")
    else:
        output = analyze_file(file_to_scan)
        print(output)

        # Option to save the analysis report with a custom path
        save_report = input("Do you want to save the analysis report to a file? (yes/no):\n").strip().lower()
        if save_report == 'yes':
            file_path = input("Enter the full path and filename (e.g., /path/to/your/report.txt):\n").strip()
            try:
                with open(file_path, "w", encoding='utf-8') as report_file:
                    report_file.write(output)
                print(f"‚úÖ Report saved as '{file_path}'.")
            except Exception as e:
                print(f"‚ùå Failed to save the report: {e}")
